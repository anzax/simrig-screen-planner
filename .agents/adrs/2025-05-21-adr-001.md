# Architecture Decision Record: SimRig Screen Planner Core Architecture

## Status

Proposed - 2025-05-21

## Context

We're migrating the SimRig Screen Planner from a React/Zustand implementation to a more modular Preact/Signals-based architecture. The current implementation mixes concerns between calculation, state management, and visualization, making it difficult to maintain and extend. Key issues include:

1. Inconsistent unit handling (inches/mm/cm) across the codebase
2. Blurred boundaries between calculation logic and visualization
3. State management tightly coupled with UI components
4. Lack of separation between physical representation and rendering
5. Limited extensibility for new features like comparison views and 3D visualization

Additionally, we want to prepare for future expansion into a comprehensive SimRig Hub with additional tools and visualization options.

## Decision

We will adopt a CAD-like domain model with clear separation between:

1. **User Input Domain**: Captures configuration through Preact Signals
2. **Calculation Domain**: Transforms inputs into physical measurements with standardized units
3. **Layout Domain**: A CAD-like representation of physical entities with 3D coordinates
4. **Visualization Domain**: Transforms layout into renderable data through projections
5. **UI State Domain**: Manages UI-specific state separate from core calculations

The flow of data will be unidirectional through pure transformation functions:

```
User Input → Calculations → Layout → Visualization
```

### Key Architecture Components

#### 1. User Input Domain

```typescript
export interface ScreenConfig {
  size: {
    diagonal: Signal<number> // inches
    aspectRatio: Signal<AspectRatio>
    inputMode: Signal<InputMode> // 'diagonal' | 'manual'
    width: Signal<number> // mm (for manual input)
    height: Signal<number> // mm (for manual input)
  }

  bezel: {
    width: Signal<number> // mm
  }

  distance: {
    eye: Signal<number> // mm
  }

  arrangement: {
    type: Signal<SetupType> // 'single' | 'triple'
    angleMode: Signal<AngleMode> // 'auto' | 'manual'
    manualAngle: Signal<number> // degrees
  }

  curvature: {
    isCurved: Signal<boolean>
    radius: Signal<number> // mm (e.g., 1800R)
  }
}
```

#### 2. Calculation Domain

```typescript
export interface CalculationResults {
  dimensions: {
    panel: { width: number; height: number } // mm
    physical: { width: number; height: number } // mm (including bezel)
  }

  angles: {
    recommendedSideAngle: number // degrees
    actualSideAngle: number // degrees
  }

  fov: {
    horizontal: number // degrees
    vertical: number // degrees
  }

  footprint: {
    totalWidth: number // mm
    depth: number // mm
  }

  curvature?: {
    chordLength: number // mm
    sagitta: number // mm (depth)
  }
}
```

#### 3. Layout Domain (CAD-like)

```typescript
export namespace SimRigLayout {
  export interface Point3D {
    x: number
    y: number
    z: number
  }

  export interface Entity {
    id: string
    type: string
    position: Point3D
    rotation: { x: number; y: number; z: number } // degrees
    visible: boolean
    layer: string
  }

  export interface Screen extends Entity {
    type: 'screen'
    width: number // mm
    height: number // mm
    bezelWidth: number // mm
    isCurved: boolean
    curveRadius?: number // mm
  }

  export interface ViewPoint extends Entity {
    type: 'viewPoint'
    eyeHeight: number // mm
    fov: { horizontal: number; vertical: number } // degrees
  }

  export interface FovRay extends Entity {
    type: 'fovRay'
    origin: Point3D
    direction: { x: number; y: number; z: number }
    length: number // mm
    angle: number // degrees from center
  }

  export interface Layout {
    screens: Screen[]
    viewPoint: ViewPoint
    fovRays: FovRay[]
    // More entity types...
    bounds: { min: Point3D; max: Point3D }
  }
}
```

#### 4. Visualization Domain

```typescript
export interface Projection {
  type: 'top-down' | 'side' | 'perspective' | 'driver-eye'
  projectPoint(point: SimRigLayout.Point3D): { x: number; y: number }
  projectEntity(entity: SimRigLayout.Entity): ProjectedEntity
}

export interface SVGRenderingData {
  elements: SVGElement[]
  viewport: { width: number; height: number; viewBox: string }
  transform: {
    toSvgPoint(point: SimRigLayout.Point3D): { x: number; y: number }
    fromSvgPoint(svgPoint: { x: number; y: number }): SimRigLayout.Point3D
  }
}
```

#### 5. UI State Domain

```typescript
export interface UiState {
  activeConfigId: Signal<'main' | 'comparison'>
  hasComparison: Signal<boolean>
  viewMode: Signal<'standard' | 'driver-eye' | 'overhead'>
  showGrid: Signal<boolean>
  showMeasurements: Signal<boolean>
  viewport: {
    zoom: Signal<number>
    center: Signal<{ x: number; y: number }>
  }
}
```

### Standardized Units

- Base unit for all physical dimensions: **millimeters**
- Screen diagonal inputs: **inches** (industry standard)
- Angles: **degrees** for input/output, **radians** for internal calculations
- Field of View: **degrees**

## Consequences

### Benefits

1. **Clear Separation of Concerns**:

   - Each domain has a distinct responsibility with clean interfaces
   - Calculations are decoupled from visualization
   - Physical representation is independent of rendering approach

2. **Improved Maintainability**:

   - Pure functions for transformations between domains
   - Standardized units reduce conversion errors
   - Well-typed interfaces clarify expectations

3. **Enhanced Testability**:

   - Each domain can be tested independently
   - Transformation functions are pure and testable
   - Mock data can be created at each layer

4. **Future-Proof for Extensions**:

   - 3D visualization becomes a natural extension
   - New entity types can be added to the layout model
   - Additional view types (driver perspective, etc.) via projections
   - Comparison feature cleanly implemented through multiple configs

5. **Better Performance**:
   - Signal-based reactivity for efficient updates
   - Layout calculations separate from rendering
   - Derived state reduces redundant calculations

### Drawbacks

1. **Initial Complexity**:

   - More abstraction layers to understand
   - More code to implement initially
   - Potential over-engineering for simple use cases

2. **Learning Curve**:

   - Team needs to understand the domain model
   - Signal-based reactivity is different from React hooks

3. **Migration Effort**:
   - Significant refactoring of existing code
   - Need to maintain backward compatibility during transition

## Implementation Plan

### Phase 1: Foundation (1-2 weeks)

1. Define core domain types and interfaces
2. Implement basic Preact Signals state management
3. Port essential calculation functions with standardized units
4. Create simple 2D top-down layout generation
5. Implement basic SVG visualization for top-down view

### Phase 2: Enhanced Features (1-2 weeks)

1. Add comparison configuration support
2. Implement curved screen calculations and visualization
3. Add FOV visualization
4. Create measurement and grid visualization
5. Implement view controls (zoom, pan)

### Phase 3: Alternative Views (1-2 weeks)

1. Implement projection system
2. Add driver's perspective view
3. Add side view projection
4. Enhance UI with view switching
5. Optimize performance for complex layouts

### Phase 4: Integration (1 week)

1. Integrate with Astro-based content hub
2. Add educational components
3. Implement configuration sharing
4. Add export functionality
5. Polish UI and interactions

## Technical Implementation Details

### Signal Architecture

```typescript
// User Config (base signals)
const config = createScreenConfig()

// UI Options
const uiState = createUiState()

// Calculations (derived)
const calculations = computed(() => calculateResults(config))

// Layout (derived)
const layout = computed(() => createLayout(config, calculations.value))

// View-specific visualization (derived)
const visualization = computed(() => createVisualization(layout.value, uiState.viewMode.value))
```

### Key Transformation Functions

```typescript
// Input → Calculations
function calculateResults(config: ScreenConfig): CalculationResults

// Calculations → Layout
function createLayout(config: ScreenConfig, calculations: CalculationResults): SimRigLayout.Layout

// Layout → Visualization
function createVisualization(layout: SimRigLayout.Layout, viewMode: string): SVGRenderingData
```

### Package Structure

```
@simrigbuild/screen-planner-core/
  ├── src/
  │   ├── input/           # User input domain
  │   ├── calculation/     # Physical calculations
  │   ├── layout/          # CAD-like layout model
  │   ├── visualization/   # Rendering & projections
  │   ├── ui/              # UI state management
  │   └── utils/           # Shared utilities
  ├── test/                # Tests for all domains
  └── examples/            # Usage examples
```

This architecture supports the current needs of the SimRig Screen Planner while providing a solid foundation for future expansion into a comprehensive SimRig Hub.
